\begin{frame}[allowframebreaks,allowdisplaybreaks]
    \subsection{Secondary Memory Access}
    \frametitle{B-Tree Secondary Memory Access}
    \begin{columns}
        \begin{column}{.7\textwidth}
            \begin{block}{}
                \begin{itemize}
                    \item The B-Tree is fairly good for storing data in external memory in comparison to height, weight or search trees.
                    \item The limit of \(2\alpha\) keys help us by having a balance availability and fragmentation of the data.
                    \item But, this limit also make that if we need to re-balance the tree the 
                        operation will take \(\Theta\left(\alpha \log n\right)\), updating all the split nodes.
                    \item This operation doesn't affect much in main memory, 
                        but in secondary memory where the access time isn't always constant 
                    \item Each read on the secondary memory can make a lot of problems in the execution of the code.
                \end{itemize}
            \end{block}
        \end{column}
        \begin{column}{.35\textwidth}
            \begin{block}{}
                \begin{figure}[h!]
                    \includegraphics[width=\linewidth]{resources/made/external_storage_wblocks.eps}
                    \caption{External storage with the sectors to access highlighted}
                \end{figure}
            \end{block}
        \end{column}
    \end{columns}

    \framebreak{}

    \begin{itemize}
        \item In summary we can see the minimun, average and maximun time and write cost of each operation in a large B-Tree, using Big-O notation.
    \end{itemize}
    \begin{center}
        \begin{tabular}{@{}ccccccc}
            \toprule
                           & Retrival & \specialcell{Insertion without \\ overflow} & \specialcell{Insertion with \\ overflow} & \specialcell{Deletion \\ with or without \\ underfull} \\
                \midrule
                \multirow[c]{2}{*}{\(\Omega\)} 
                    & \(t = 1\) & \(t = h \) & \(t = h\) & \(t = h\) \\
                    & \(w = 0\) & \(w = 1\) & \(w = 1\) & \(w = 1\) \\
                \midrule
                \multirow[c]{2}{*}{\(\Theta\)} 
                    & \(t \leq h\) & \(t = h\) & \(t \leq h + 2 + \frac{2}{\alpha}\) & \(t \leq 3h - 2\) \\
                    & \(w = 0\) & \(w < 1 + \frac{2}{\alpha}\) & \(w \leq 3 + \frac{2}{\alpha}\) & \(w \leq 2h +1\) \\
                \midrule
                \multirow[c]{2}{*}{\(O\)}
                    & \(t = h\) & \(t = h\) & \(t = 3h - 2\) & \(t = 3h - 2\) \\
                    & \(w = 0\) & \(w = 2h + 1\) & \(w = 2h + 1\) & \(w = 2h + 1\) \\
            \toprule
        \end{tabular}
    \end{center}
    \begin{itemize}
        \item Where \(t\) is the number of fetch and readings of nodes on the secondary memory.
        \item And \(w\) is the number of writings of nodes on the secondary memory.~\parencite{bayer_organization_1972}.
    \end{itemize}\end{frame}
